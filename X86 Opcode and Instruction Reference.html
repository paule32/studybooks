<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!--
      generated using
      libxslt1.0,
      http://xmlsoft.org/XSLT/-->
<!--
              Discussion on
            [url=http://x86asm.net/projects/x86reference]X86 Opcode and Instruction Reference[/url]project.[quote]This reference is intended to be precise opcode and instruction set
  reference (including x86-64). Its principal aim is exact definition
  of instruction parameters and attributes.[/quote]News in this revision:[quote][/quote]

New revision is out. Use the original link to see it.

This thread is locked.-->
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<title>X86 Opcode and Instruction Reference</title>
<meta name="description" content="This reference is intended to be precise opcode and instruction set
  reference (including x86-64). Its principal aim is exact definition
  of instruction parameters and attributes.">
<link href="X86%20Opcode%20and%20Instruction%20Reference-Dateien/main_v2.css" rel="stylesheet" type="text/css" media="screen">
<link rel="shortcut icon" href="http://ref.x86asm.net/favicon.ico">
<link rel="alternate" type="application/atom+xml" title="x86asm.net" href="http://x86asm.net/atom.xml">
<style type="text/css">/* This is not a zero-length file! */</style><style type="text/css">/* This is not a zero-length file! */</style></head>
<body>
<div class="menu">
<div style="text-align: center;"><a href="http://x86asm.net/index.html">x86asm.net</a></div>
<hr>
<!--<DIV><A HREF="#Store">Store</A></DIV>-->
<div><a href="#HTML-Editions">HTML Editions</a></div>
<div><a href="#Using-HTML-Editions">Using HTML Editions</a></div>
<div><a href="#Columns-Description">Columns Description</a></div>
<div><a href="#Instruction-Operand-Codes">Instruction Operand Codes</a></div>
<div><a href="#Current-State">Current State</a></div>
<div><a href="#Implementations">Implementations</a></div>
<div><a href="#License">License</a></div>
<div><a href="#Resources">Resources</a></div>
<div><a href="#Credits">Credits</a></div>
<div><a href="#References">References</a></div>
<div><a href="#Download">Download</a></div>
<a href="#Comments">Comments</a>
</div>
<div class="page-inside">
<h1>X86 Opcode and Instruction Reference</h1>
<table class="metainfo noborder" cellpadding="3"><tbody class="noborder"><tr class="noborder">
<td class="noborder">
<b>MazeGen</b>,
              2017-02-18</td>
<td style="text-align: right;" class="noborder">Revision: <a href="#rev_history" title="Revision History">1.12</a>
</td>
</tr></tbody></table>
<p>This reference is intended to be precise opcode and instruction set
  reference (including x86-64). Its principal aim is exact definition
  of instruction parameters and attributes.</p>
<h3>Quick Navigation</h3>
<p><a href="http://ref.x86asm.net/coder32.html">coder32</a>,
    <a href="http://ref.x86asm.net/coder32-abc.html">coder32-abc</a>,
    <a href="http://ref.x86asm.net/geek32.html">geek32</a>,
    <a href="http://ref.x86asm.net/geek32-abc.html">geek32-abc</a></p>
<p><a href="http://ref.x86asm.net/coder64.html">coder64</a>,
    <a href="http://ref.x86asm.net/coder64-abc.html">coder64-abc</a>,
    <a href="http://ref.x86asm.net/geek64.html">geek64</a>,
    <a href="http://ref.x86asm.net/geek64-abc.html">geek64-abc</a></p>
<p><a href="http://ref.x86asm.net/coder.html">coder</a>,
    <a href="http://ref.x86asm.net/coder-abc.html">coder-abc</a>,
    <a href="http://ref.x86asm.net/geek.html">geek</a>,
    <a href="http://ref.x86asm.net/geek-abc.html">geek-abc</a> (these
    contain both x86-32 and x64 instructions).
  </p>
<p>In contrast to other references, primary source of
  this reference is an <a onclick="javascript:urchinTracker ('downloads/x86reference.xml');" href="http://ref.x86asm.net/x86reference.xml">XML</a> document, which guarantees
  clear and structured information base and therefore ability to extract
  many various informations such as a list of instructions from requested
  groups, etc.</p>
<p>The reference is primarily based on Intel manuals as
  Intel is the originator of x86 architecture. Additionally, it
  describes undocumented instructions as well. On appropriate
  places, it gives a notice if an opcode act differently on
  <abbr>AMD</abbr> architecture. Support for Cyrix, NexGen
  etc. specific instructions is not scheduled at all.</p>
<!--
<H2 ID="Store"><a href="store/index.html">Store</a></H2>
<p><i>Get one copy for <strong>$20</strong>,
  two copies for <strong>$32</strong>.</i></p>
<p>Immediately following the initial release of the
  reference, it emerged that a large number of users are interested in
  a printed version. You can order a copy in <a href="store/index.html">the on-line store</a>.</p>
-->
<h2 id="HTML-Editions">
<abbr>HTML</abbr> Editions</h2>
<p>These editions are available at the moment:
  The <dfn>coder</dfn> suite is intended to more common use and
  contains the following editions:
  <a href="http://ref.x86asm.net/coder32.html">coder32</a>,
  <a href="http://ref.x86asm.net/coder64.html">coder64</a>, and 
  <a href="http://ref.x86asm.net/coder.html">coder</a> (sorted by
  opcode), and
  <a href="http://ref.x86asm.net/coder32-abc.html">coder32-abc</a>,
  <a href="http://ref.x86asm.net/coder64-abc.html">coder64-abc</a>, and 
  <a href="http://ref.x86asm.net/coder-abc.html">coder-abc</a> (sorted by
  mnemonic).
  The <dfn>geek</dfn> suite is intended for deeper research of
  x86 architectures' instruction set. This includes
  <a href="http://ref.x86asm.net/geek32.html">geek32</a>, 
  <a href="http://ref.x86asm.net/geek64.html">geek64</a>, and
  <a href="http://ref.x86asm.net/geek.html">geek</a> editions (by opcode)
  and
  <a href="http://ref.x86asm.net/geek32-abc.html">geek32-abc</a>, 
  <a href="http://ref.x86asm.net/geek64-abc.html">geek64-abc</a>, and
  <a href="http://ref.x86asm.net/geek-abc.html">geek-abc</a> editions (by
  mnemonic).
  More on the purpose and use of this suite see close below.</p>
<p>Don't get confused by geek(-abc) and coder(-abc) editions. Both
  of them contains instruction set of both x86-32 and x86-64
  architectures. If you don't have a particular reason to use them
  (such as to view the differencies between the architectures), the
  other editions would probably suit you better.</p>
<p>Editions coder32 a geek32 relate exclusively to
  x86-32 architecture. Similarly, editions coder64 and geek64 relate
  exclusively to x86-64 architecture.</p>
<p>The following chart illustrates the differencies between
  editions for current release:</p>
<table cellpadding="7">
    <tbody>

      <tr>
	<td colspan="2"><strong>Edition</strong></td>
	<td>coder</td>
	<td>coder32</td>
	<td>coder64</td>
	<td>geek</td>
	<td>geek32</td>
	<td>geek64</td>
      </tr>
    </tbody>
    <tbody>
      <tr>
	<td colspan="2"><strong>Supported Architectures</strong></td>
	<td>both</td>
	<td>pure x86-32</td>
	<td>pure x86-64</td>
	<td>both</td>
	<td>pure x86-32</td>
	<td>pure x86-64</td>
      </tr>
      <tr>
	<td colspan="2"><strong>Operand Codes</strong></td>
	<td>traditional</td>
	<td>traditional</td>
	<td>traditional</td>
	<td>special</td>
	<td>special</td>
	<td>special</td>
      </tr>
      <tr>
	<td colspan="2"><strong>Abandoned Instructions</strong></td>
	<td>no</td>
	<td>no</td>
	<td>no</td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
      </tr>
      <tr>
	<td colspan="2"><strong>Opcode Bitfields Information</strong></td>
	<td>no</td>
	<td>no</td>
	<td>no</td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
      </tr>
      <tr>
	<td colspan="2"><strong>Instruction Extension Indicated</strong></td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
      </tr>
      <tr>
	<td colspan="2"><strong>Instruction Group Indicated</strong></td>
	<td>no</td>
	<td>no</td>
	<td>no</td>
	<td>yes</td>
	<td>yes</td>
	<td>yes</td>
      </tr>
      <tr>
	<td rowspan="8"><strong>Present Instructions</strong></td>
	<td><strong>general</strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>
      <tr>
	<td><strong>system</strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>
      <tr>
	<td><strong>x87&nbsp;<abbr>FPU</abbr></strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>
      <tr>
	<td><strong>MMX</strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>
      <tr>
	<td><strong><abbr>Intel SSE (all)</abbr></strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>



      <tr>
	<td><strong><abbr title="Intel Virtualization Technology Extensions">VMX</abbr></strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>

      <tr>
	<td><strong><abbr title="Intel Safer Mode Extensions">SMX</abbr></strong></td>
	<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>

      <tr>
	<td><strong>Itanium</strong></td>
	<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
      </tr>
    </tbody>
  </table>
<h3>The Purpose of Geek Editions in Short</h3>
<p>The geek editions contains as much complete
  information from the <a href="#Source_XML_Document_desc">source XML document</a> as possible. That's why
  they may seem quite unclear. You appreciate them only if you need to
  get to know the instruction set deeply or if you investigate the
  source <abbr>XML</abbr> and you need to visualize it better.</p>
<p>These editions use specific operand codes (which
  are described in Instruction Operand Codes chapter below). These
  codes may look strange and obscure at the first sight. The reason to
  use them is that they hold more information than the more common
  ones. One example can be operand combination
  <code>rAX,&nbsp;imm16/32</code>, such as in instruction
  <code><a href="http://ref.x86asm.net/coder64.html#x05">ADD&nbsp;rAX,&nbsp;imm16/32</a></code> in <a href="http://ref.x86asm.net/coder64.html">coder64</a> edition. One can
  determine that the destination operand is either
  <code>ax</code>, <code>eax</code>, or <code>rax</code>, and the
  source one is either <code>imm16</code> or
  <code>imm32</code>. A problem arises when one needs to determine what
  magic is behind <code>rax,&nbsp;imm32</code> combination. If one is
  just getting started with x64 architecture, it is not clear how
  exactly is 32-bit immediate added to 64-bit <code>rax</code>. This
  question is answered by corresponding geek edition, <code><a href="http://ref.x86asm.net/geek64.html#x05">ADD&nbsp;rAX,&nbsp;Ivds</a></code> in <a href="http://ref.x86asm.net/geek64.html">geek64</a> edition. The immediate
  value is encoded there using <code>Ivds</code> code. <code>I</code>
  code means <dfn>Immediate</dfn>, <code>v</code> means
  <dfn>word</dfn> or <dfn>doubleword</dfn> (<code>imm16</code> or
  <code>imm32</code>). The most important part is <code>ds</code>
  code, which means <dfn>doubleword, sign-extended to 64
  bits for 64-bit operand size</dfn>. Now is it clear.</p>
<p>As for Itanium-specific instructions,
  they are added just for the sake of interest - they give a notice
  that the appropriate opcodes are already used.</p>
<h3>Hypertext Reference to Particular Opcode</h3>
<p>If you want to refer to
  particular opcode (in any edition), e.&nbsp;g., <code>0FA0&nbsp;PUSH&nbsp;FS</code>, it can be
  easily achieved this way:</p>
<p><kbd>ref.x86asm.net/geek.html#x0FA0</kbd>
    (<a href="http://ref.x86asm.net/geek.html#x0FA0">try it</a>)
  </p>
<p>It works for opcode extension similarly, e.&nbsp;g., <code>83&nbsp;/7&nbsp;CMP</code>:</p>
<p><kbd>ref.x86asm.net/coder32.html#x83_7</kbd>
    (<a href="http://ref.x86asm.net/coder32.html#x83_7">try it</a>)
  </p>

<!--
<h3>Printing</h3>
<p>You can order a printed copy in <a href="store/index.html">the on-line
  store</a>. This is how a copy looks like:</p>
<DIV STYLE="text-align: center"><img style="width: 384px; height:288px;" alt="printed_reference_inside.jpg" src="printed_reference_inside.jpg"></DIV>
-->

<h2 id="Using-HTML-Editions">Using <abbr>HTML</abbr> Editions</h2>
<p>Since <abbr>HTML</abbr> editions can look
  complicated at first sight, here goes an outline how to work with
  them. Following examples come from <a href="http://ref.x86asm.net/coder32.html">coder32's</a> edition because it is
  easier to use than geek's editions.</p>
<h3>Example: ADC Instruction</h3>
<p>Let's start with more known instruction, such as
  <code><a href="http://ref.x86asm.net/coder32.html#x11">ADC</a></code>.
  We find something similar to the following:</p>
<pre>|pf|0F|po|so|flds|o|proc|st|m|rl|l|mnemonic|op1     |op2   |op3|op4|iext|grp1|grp2 |tested f|modif f |def f   |undef f|f values|description, notes|
|  |  |11|  |    |r|    |  | |  |L|ADC     |<b>r/m16/32</b>|r16/32|   |   |    |gen |arith|.......c|o..szapc|o..szapc|       |        |Add with Carry    |</pre>
<p>First column <a href="#column_pf">pf</a> (Prefix) is empty. That means the instruction's
  opcode doesn't contain any fixed prefix.</p>
<p>Next column <a href="#column_0F">0F</a> is just allocated for
  <code>0F</code> prefix for multiple-byte opcodes so it is
  empty.</p>
<p>Next column <a href="#column_po">po</a> (Primary Opcode) holds
  primary opcode value itself.</p>
<p>Because the instruction's opcode
  doesn't contain any added byte, the column <a href="#column_so">so</a> (Secondary Opcode) is empty too.</p>
<p>The opcode doesn't contain any specific bits so the
  column <a href="#column_flds">flds</a> (Opcode
  Fields) is empty.</p>
<p>The column <a href="#column_o">o</a> (Register/Opcode Field) here holds "r", which
  indicates that the instruction uses "full" ModR/M byte (no opcode extension).</p>
<p>Because this instruction is supported since 8086 processor,
  <a href="#column_proc">proc</a> column
  (Introduced with Processor) is empty.</p>
<p>This instruction is officially documented
  so <a href="#column_st">st</a> column
  is empty too.</p>
<p>Instruction <code>ADC</code> can work on any ring level
  so the column <a href="#column_rl">rl</a>, Ring Level, is empty.</p>
<p>The column <a href="#column_x">x</a> holds "L", which means that
  <code>LOCK</code> prefix is allowed with this instruction.</p>
<p>Next three columns, <a href="#column_mnemonic">mnemonic</a>, <a href="#column_op">op1 and op2</a> show instruction's
  syntax. The destination operand of this instruction is set up using
  bold, what always means the operand is modified by the instruction.</p>
<p>The column <a href="#column_iext">iext</a> (Instruction Extension
  Group) is empty because the instruction doesn't
  belong to any instruction set extension.</p>
<p>Columns <a href="#column_grp1_grp2_grp3">grp1
  and&nbsp;grp2</a> classify the instruction among general
  arithmetic instructions.</p>
<p><code>ADC</code> instruction is influenced
  by CF flag, what represents <a href="#column_tested_f_modif_f_def_f_undef_f">tested&nbsp;f</a> column.</p>
<p>This instruction influences (overwrites) all status
  flags. These can be found in next column <a href="#column_tested_f_modif_f_def_f_undef_f">modif&nbsp;f</a> column.</p>
<p>All of these flags are defined (don't contain random
  values) so the same flags are in next <a href="#column_tested_f_modif_f_def_f_undef_f">def&nbsp;f</a> column, and <a href="#column_tested_f_modif_f_def_f_undef_f">undef&nbsp;f</a> column must be empty.</p>
<p>No flag is set to a fixed value (all modified flags
  depend on input operands) so <a href="#column_tested_f_modif_f_def_f_undef_f">f&nbsp;values</a> column is empty.</p>
<p>Last column <a href="#column_description_notes">description,
  notes</a> contains only a general description of the instruction.</p>
<h3>Example: Opcode Extensions</h3>
<p>Some opcodes (only a few) depend on Opcode
  Extension Field in ModR/M byte. Using this field, the opcode is
  actually extended by three bits. In most cases, different extension
  of the same opcode means more or less different instruction. An
  example can be opcode <code><a href="http://ref.x86asm.net/coder32.html#xF6">F6</a></code>. We choose last three extensions of
  the opcode:</p>
<pre>|pf|0F|po|so|flds|o|proc|st|m|rl|l|mnemonic|op1|op2|op3 |op4 |iext|grp1|grp2 |tested f|modif f |def f   |undef f |f values|description, notes|
----------------------------------------------------------------------------------------------------------------------------------------------
|  |  |F6|  |    |5|    |  | |  | |IMUL    |<b><i>AX</i></b> |<i>AL</i> |r/m8|    |    |gen |arith|        |o..szapc|o......c|...szap.|        |Signed Multiply   |
----------------------------------------------------------------------------------------------------------------------------------------------
|  |  |F6|  |    |6|    |  | |  | |DIV     |<b><i>AL</i></b> |<b><i>AH</i></b> |<i>AX</i>  |r/m8|    |gen |arith|        |o..szapc|        |o..szapc|        |Unsigned Divide   |
----------------------------------------------------------------------------------------------------------------------------------------------
|  |  |F6|  |    |7|    |  | |  | |IDIV    |<b><i>AL</i></b> |<b><i>AH</i></b> |<i>AX</i>  |r/m8|    |gen |arith|        |o..szapc|        |o..szapc|        |Signed Divide     |</pre>
<p>The opcode extension can be a value from&nbsp;0
  through&nbsp;7. These values are indicated in <a href="#column_o">o</a> (Register/Opcode Field) column. In this
  example, values&nbsp;5,&nbsp;6, and&nbsp;7 are chosen.</p>
<p>Additionally, this example shows that operands, which
  are not explicitly used (<code>AL</code>,
  <code>AH</code>, and <code>AX</code> operands), are set up using
  italic. It also shows that <code>DIV</code> and <code>IDIV</code>
  instructions always destroy all status flags: both <a href="#column_tested_f_modif_f_def_f_undef_f">modif&nbsp;f</a> and <a href="#column_tested_f_modif_f_def_f_undef_f">undef&nbsp;f</a> column contain these flags.</p>
<h3>Example: One Opcode, More Syntaxes</h3>
<p>Some opcodes are represented by more instructions
  with the same meaning, using different syntaxes. (This doesn't apply
  to the case when an opcode depends on Opcode Extension field in
  ModR/M byte. In this case, these instructions act more or less
  differently). Best known example are conditional jumps, for example
  <code><a href="http://ref.x86asm.net/coder32.html#x74">JZ/JE</a></code>, where we find something similar:</p>
<pre>|pf|0F|po|so|flds|o|proc|st|m|rl|l|mnemonic|op1     |op2|op3|op4|iext|grp1|grp2  |tested f|modif f|def f|undef f|f values|description, notes             |
|  |  |74|  |    | |    |  | |  | |JZ      |rel8    |   |   |   |    |gen |branch|....z...|       |     |       |        |Jump short if zero/equal (ZF=0)|
|  |  |  |  |    | |    |  | |  | |JE      |rel8    |   |   |   |    |    |      |        |       |     |       |        |                               |</pre>
<p>Each syntax has dedicated row in <a href="#column_mnemonic">mnemonic</a> column
  and in columns with instruction <a href="#column_op">operands</a>.</p>
<p>More complex case is, for example,
  <code><a href="http://ref.x86asm.net/coder32.html#xA5">MOVS/MOVSW/MOVSD</a></code> instruction:</p>
<pre>|pf|0F|po|so|flds|o|proc|st|m|rl|l|mnemonic|op1   |op2   |op3|op4|iext|grp1|grp2   |tested f|modif f|def f|undef f|f values|description, notes             |
------------------------------------------------------------------------------------------------------------------------------------------------------------
|  |  |A5|  |    | |    |  | |  | |MOVS    |<b>m16</b>   |m16   |   |   |    |gen |datamov|.d......|       |     |       |        |Move Data from String to String|
|  |  |  |  |    | |    |  | |  | |MOVSW   |<b><i>m16</i></b>   |<i>m16</i>   |   |   |    |    |string |        |       |     |       |        |                               |
------------------------------------------------------------------------------------------------------------------------------------------------------------
|  |  |A5|  |    | |03+ |  | |  | |MOVS    |<b>m16/32</b>|m16/32|   |   |    |gen |datamov|.d......|       |     |       |        |Move Data from String to String|
|  |  |  |  |    | |    |  | |  | |MOVSD   |<b><i>m32</i></b>   |<i>m32</i>   |   |   |    |    |string |        |       |     |       |        |                               |</pre>
<p>Here, the opcode's record is complicated by the fact
  that since 80386 processor, the syntax is extended (thanks to 32-bit
  operands) with <code>MOVSD</code> mnemonic and <code>MOVS</code>
  syntax is changed. That's why all four syntaxes have to be split by
  twos.</p>
<p>More examples with multiple syntaxes:
  <code><a href="http://ref.x86asm.net/coder32.html#x60">PUSHA/PUSHAD</a></code>,
  <code><a href="http://ref.x86asm.net/coder32.html#xD0_4">SHL/SAL</a></code>, or
  <code><a href="http://ref.x86asm.net/coder32.html#x0F00_0">SLDT</a></code>.</p>
<h3>Example: Undocumented Instruction <abbr>SETALC</abbr>
</h3>
<p>All main editions contain a few undocumented
  instructions (from the Intel manual point of view). No that in this
  reference, undocumented doesn't equal invalid. All undocumented
  instructions mentioned by this reference work well in their
  shape. It is, for example, <code><a href="http://ref.x86asm.net/coder32.html#xD6">SETALC</a></code> instruction:</p>
<pre>|pf|0F|po|so|flds|o|proc|st|m|rl|l|mnemonic|op1|op2|op3|op4|iext|grp1|grp2   |tested f|modif f |def f|undef f|f values|description, notes                           |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
|  |  |D6|  |    | |02+ |D<a href="http://ref.x86asm.net/geek32.html#gen_note_D6_F1"><sup>5</sup></a>| |  | |<i>undefined</i>               |    |    |       |        |        |     |       |        |Undefined and Reserved; Does not Generate #UD|
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
|  |  |D6|  |    | |02+ |U<a href="http://ref.x86asm.net/geek32.html#gen_note_u_D6_F1"><sup>6</sup></a>| |  | |SALC    |<i><b>AL</b></i> |   |   |   |    |gen |datamov|.......c|        |     |       |        |Set AL If Carry                              |
|  |  |  |  |    | |    |  | |  | |SETALC  |<i><b>AL</b></i> |   |   |   |    |    |       |        |        |     |       |        |                                             |</pre>
<p>In this case, the documented meaning
  goes first, as indicated in <a href="#column_st">st</a> column by "D" value. Since this opcode's
  documented meaning is not a common one, there is additional
  reference to the description where the opcode is documented. The column
  <a href="#column_mnemonic">mnemonic</a> implies by
  the value "undefined" (which is set up using italic, which
  always means here that it is not an original mnemonic) that the
  documented meaning of this opcode is "undefined and reserved". This
  is also stated in the last column.</p>
<p>Below goes the undocumented meaning of the opcode -
  <a href="#column_st">st</a> column holds "U"
  value. Each undocumented meaning should contain a reference to
  the description where is the opcode unofficially documented, like in
  this case.</p>
<p>More examples of undocumented instructions:
  <code><a href="http://ref.x86asm.net/coder32.html#xF1">INT1/ICEBP</a></code> or
  <code><a href="http://ref.x86asm.net/coder32.html#xF6_1">TEST</a></code>.</p>
<h2 id="Columns-Description">Columns Description</h2>
<p>Quick navigation:</p>
<ul>
    <li>
<a href="#column_pf">pf</a> Prefix</li>
    <li>
<a href="#column_0F">0F</a> <code>0F</code>&nbsp;Prefix</li>
    <li>
<a href="#column_po">po</a> Primary Opcode</li>
    <li>
<a href="#column_so">so</a> Secondary Opcode</li>
    <li>
<a href="#column_flds">flds</a> Opcode Fields</li>
    <li>
<a href="#column_o">o</a> Register/Opcode Field</li>
    <li>
<a href="#column_proc">proc</a> Introduced with Processor</li>
    <li>
<a href="#column_st">st</a> Documentation Status</li>
    <li>
<a href="#column_m">m</a> Mode of Operation</li>
    <li>
<a href="#column_rl">rl</a> Ring Level</li>
    <li>
<a href="#column_x">x</a> Lock Prefix/FPU Push/FPU Pop</li>
    <li>
<a href="#column_mnemonic">mnemonic</a> Instruction Mnemonic</li>
    <li>
<a href="#column_op">op1, op2, &#8230;</a> Instruction Operands</li>
    <li>
<a href="#column_iext">iext</a> Instruction Extension Group</li>
    <li>
<a href="#column_grp1_grp2_grp3">grp1, grp2, grp3</a> Main Group, Sub-group, Sub-sub-group</li>
    <li>
<a href="#column_tested_f_modif_f_def_f_undef_f">tested&nbsp;f, modif&nbsp;f, def&nbsp;f,
    undef&nbsp;f</a> Tested, Modified, Defined, and Undefined Flags</li>
    <li>
<a href="#column_f_values">f&nbsp;values</a> Flags Values</li>
    <li><a href="#column_description_notes">description, notes</a></li>
  </ul>
<p></p><table cellpadding="6">
      <colgroup><col style="vertical-align: top" span="2">
      </colgroup><thead>
	<tr>
	  <th>Name</th>
	  <th>Meaning</th>
	  <th>Description, Examples</th>
	</tr>
      </thead>
      <tbody>
	<tr id="column_pf">
	  <td><abbr>pf</abbr></td>
	  <td>Prefix</td>
	  <td>Fixed extraordinary prefix, which may change the semantic of
	  the Primary Opcode. Usually used in case of waiting
	  x87&nbsp;<abbr>FPU</abbr> instructions, and many
	  <abbr>SSE</abbr> instructions.
            <code><a href="http://ref.x86asm.net/geek.html#x90">F390</a>&nbsp;PAUSE</code>,
            <code><a href="http://ref.x86asm.net/geek.html#xD9_7">9BD9/7</a>&nbsp;FSTCW</code>,
            <code><a href="http://ref.x86asm.net/geek.html#x0F10">F30F10</a>&nbsp;MOVSS</code>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_0F">
	  <td><code>0F</code></td>
	  <td>
<code>0F</code>&nbsp;Prefix</td>
	  <td>Dedicated for <code>0F</code>&nbsp;Prefix.
            <code><a href="http://ref.x86asm.net/geek.html#x0F00">two-byte opcodes</a></code>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_po">
	  <td><abbr>po</abbr></td>
	  <td>Primary Opcode</td>
	  <td>Basic opcode. Second opcode byte in case of two- and
	  three-byte opcodes. For coder's editions: <code>+r</code>
	  means a register code, from 0&nbsp;through&nbsp;7, added to the
	  value. <code><a href="http://ref.x86asm.net/coder.html#x50">50&nbsp;PUSH</a></code>
</td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_so">
	  <td><abbr>so</abbr></td>
	  <td>Secondary Opcode</td>
	  <td>Fixed appended value to the primary opcode. It is used
	  in some special cases, x87&nbsp;<abbr>FPU</abbr>
	  instructions and for new <strong>three-byte</strong> instructions.
            <code><a href="http://ref.x86asm.net/geek.html#xD4">D40A</a>&nbsp;AAM</code>,
            <code><a href="http://ref.x86asm.net/geek.html#xD5">D50A</a>&nbsp;AAD</code>,
            <code><a href="http://ref.x86asm.net/geek.html#xD9_5">D5F8</a>&nbsp;FLD1</code>,
            three-byte escape <code><a href="http://ref.x86asm.net/geek.html#x0F38">0F38</a></code>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_flds">
	  <td><abbr>flds</abbr></td>
	  <td>Opcode Fields</td>
	  <td>This column is present only in geek's editions. It
	  contain present Primary Opcode binary fields. These are:
            <ul>
	      <li>
<code>+r</code> means a register code, from
	      0&nbsp;through&nbsp;7, added to the basic value of the Primary
	      Opcode.
              <code><a href="http://ref.x86asm.net/geek.html#x40">40&nbsp;INC</a></code>
              </li>
	    </ul>

	    The following fields are case-sensitive: if a letter of the code
	    is set up in lower case, it means the appropriate bit is
	    cleared, otherwise is set.
            <ul>
	      <li>
<code>w</code> means bit <code>w</code> (bit
	      index&nbsp;0, <dfn>operand size</dfn>) is present; may
	      be combined with bits
	      <code>d</code> or&nbsp;<code>s</code>.
              <code><a href="http://ref.x86asm.net/geek.html#x04">04&nbsp;ADD</a></code>
              </li>
	      <li>
<code>s</code> means bit&nbsp;<code>s</code> (bit
	      index&nbsp;1, <dfn>Sign-extend</dfn>) is present; may be combined with
	      bit&nbsp;<code>w</code>.
              <code><a href="http://ref.x86asm.net/geek.html#x6B">6B&nbsp;IMUL</a></code>
              </li>
	      <li>
<code>d</code> means bit <code>d</code> (bit
	      index&nbsp;1, <dfn>Direction</dfn>) is present; may be combined
	      with bit&nbsp;<code>w</code>.
              <code><a href="http://ref.x86asm.net/geek.html#x00">00&nbsp;ADD</a></code>
              </li>
	      <li>
<code>tttn</code> means bit field <code>tttn</code>
	      (4 bits, bit index&nbsp;0, <dfn>condition</dfn>). Used
	      only with conditional instructions.
              <code><a href="http://ref.x86asm.net/geek.html#x70">70&nbsp;JO</a></code>
              </li>
	      <li>
<code>sr</code> means segment register specifier -
	      a&nbsp;code of one of original four segment registers (2
	      bits, bit index&nbsp;3). See also <code>S2</code>
	      addressing method.
              <code><a href="http://ref.x86asm.net/geek.html#x06">06&nbsp;PUSH</a></code>
              </li>
	      <li>
<code>sre</code> means segment register specifier -
	      a&nbsp;code of any segment registers (3 bits, bit
	      index&nbsp;0 or&nbsp;3). See also <code>S30</code> and
	      <code>S33</code> addressing methods.
              <code><a href="http://ref.x86asm.net/geek.html#x0FA0">0FA0&nbsp;PUSH</a></code>
              </li>
	      <li>
<code>mf</code> means bit field <abbr>MF</abbr>
	       (2 bits, bit index&nbsp;1, <dfn>memory format</dfn>); used only with
	      <abbr>x87&nbsp;FPU</abbr> instructions coded with second
	      floating-point instruction format.
              <code><a href="http://ref.x86asm.net/geek.html#xDA_0">DA/0</a>&nbsp;FIADD</code>
              </li>
	    </ul>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_o">
	  <td><abbr>o</abbr></td>
	  <td>Register/ Opcode Field</td>
	  <td>
            <ol>
	      <li>The value of the opcode extension (values
	      from&nbsp;0 through&nbsp;7).
              <code><a href="http://ref.x86asm.net/geek.html#x80">group&nbsp;80</a></code>
              </li>
	      <li>
<code>r</code> indicates that the ModR/M
              byte contains a register operand and an r/m operand.
              <code><a href="http://ref.x86asm.net/geek.html#x00">00&nbsp;ADD</a></code>
              </li>
	    </ol>
	  </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_proc">
	  <td><abbr>proc</abbr></td>
	  <td>Introduced with Processor</td>
	  <td>Indicates the instruction's introductory processor
	  (code in curves apply to XML reference):
            <ul>
	      <li>
<code>00</code>: 8086</li>
	      <li>
<code>01</code>: 80186</li>
	      <li>
<code>02</code>: 80286</li>
	      <li>
<code>03</code>: 80386</li>
	      <li>
<code>04</code>: 80486</li>
	      <li>
<code>P1</code> (<code>05</code>): Pentium&nbsp;(1)</li>
<li>
<code>PX</code> (<code>06</code>): Pentium with&nbsp;<abbr>MMX</abbr>
</li>
<li>
<code>PP</code> (<code>07</code>): Pentium&nbsp;Pro</li>
<li>
<code>P2</code> (<code>08</code>): Pentium&nbsp;II</li>
<li>
<code>P3</code> (<code>09</code>): Pentium&nbsp;III</li>
<li>
<code>P4</code> (<code>10</code>): Pentium&nbsp;4</li>
<li>
<code>C1</code> (<code>11</code>): Core&nbsp;(1)</li>
<li>
<code>C2</code> (<code>12</code>): Core&nbsp;2</li>
<li>
<code>C7</code> (<code>13</code>): Core&nbsp;i7</li>
<li>
<code>IT</code> (<code>99</code>): Itanium (only geek editions)</li>
	    </ul>
	      The opcodes that are not forward-compatible (the
	      ones which have been abandoned) are present only in
	      geek's editions.
            <ol>
	      <li>If the processor marking is a range (e.g., <code>03-04</code>), it means that the
                instruction is unsupported in latter processors.
                <code><a href="http://ref.x86asm.net/geek.html#x0F24">0F24&nbsp;MOV</a></code>
              </li>
	      <li>
<code>+</code> (e.&nbsp;g., <code>00+</code>) means the instruction is supported in any
                of latter processors and also in 64-bit mode, if the next row doesn't explicitly say otherwise.
                <code><a href="http://ref.x86asm.net/geek.html#x06">06&nbsp;PUSH&nbsp;ES</a></code>
              </li>
	      <li>
<code>++</code> (e.&nbsp;g., <code>P4++</code>) the same meaning, but only in the latter
                steppings of the processor (e.&nbsp;g., <abbr>SSE3</abbr> instruction extensions).
                <code><a href="http://ref.x86asm.net/geek.html#x0FA2">0FA2&nbsp;CPUID</a></code>
              </li>
	    </ol>
            If this column is empty: In case of 32-bit editions, it
            means <code>00+</code> (8086 and all latter
            processors). In case of 64-bit editions, it means
            <code>P4++</code> (P4, latter stepping, and all latter
            processors), because Intel&nbsp;64 Architecture is
            available since latter stepping of the Pentium&nbsp;4 processor.
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_st">
	  <td><abbr>st</abbr></td>
	  <td>Document. Status</td>
	  <td>Indicates how is the instruction documented in the Intel
	  manuals:
            <ol>
	      <li>
<code>D</code> means fully documented. It can
	      contain a reference to description which chapter in
	      Intel manual it is documented in, if it may be
	      unclear.
              <code><a href="http://ref.x86asm.net/geek.html#xD6">D6</a></code>
              </li>
	      <li>
<code>M</code> means documented only marginally.
              <code><a href="http://ref.x86asm.net/geek.html#x66">66&nbsp;(SSE2)</a></code>
              </li>
	      <li>
<code>U</code> undocumented at all. It should
	      contain a reference to description of the source. Note
	      that in this reference, undocumented doesn't equal invalid.
	      All mentioned undocumented instructions should work well in their scope.
              <code><a href="http://ref.x86asm.net/geek.html#xD6">D6&nbsp;SALC</a></code>
              </li>
	    </ol>
          If this column is empty, it means <code>D</code> (documented with no further notes).
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_m">
	  <td><abbr>m</abbr></td>
	  <td>Mode of Operation</td>
	  <td>Indicates the mode, which is the instruction
	  valid&nbsp;on. Virtual-8086 Mode is not taken into account.
            <ol>
	      <li>
<code>R</code> applies for real, protected and 64-bit
	      mode. <abbr>SMM</abbr> is not taken into account.
              </li>
	      <li>
<code>P</code> applies for protected and 64-bit mode.
	      <abbr>SMM</abbr> is not taken into account.
              <code><a href="http://ref.x86asm.net/geek.html#x0F00">group&nbsp;0F00</a></code>
              </li>
	      <li>
<code>E</code> applies for 64-bit
	      mode. <abbr>SMM</abbr> is not taken into account.
              <code><a href="http://ref.x86asm.net/geek.html#x63">63&nbsp;MOVSXD</a></code>
              </li>
	      <li>
<code>S</code> applies for <abbr>SMM</abbr>.
              <code><a href="http://ref.x86asm.net/geek.html#x0FAA">0FAA&nbsp;RSM</a></code>
              </li>
	    </ol>
            If this column is empty, it means <code>R</code>. For
            64-bit editions, <code>E</code>&nbsp;code indicates in
            most cases that the
            semantics of the opcode is specific to 64-bit mode.
          </td>
	</tr>
      </tbody>

      <tbody>
	<tr id="column_rl">
	  <td><abbr>rl</abbr></td>
	  <td>Ring Level</td>
	  <td>The ring level, which is the instruction valid (3
	    or&nbsp;0) from; <code>f</code>&nbsp;indicates that the level
	    depends on a flag(s) and it should contain a reference to the
	    description of that flag, if the flag is not too complex. If
	    this column is empty, it means ring&nbsp;3.
            <code><a href="http://ref.x86asm.net/geek.html#xCD">INT</a></code>,
            <code><a href="http://ref.x86asm.net/geek.html#x6C">INS</a></code>,
            <code><a href="http://ref.x86asm.net/geek.html#x0F31">RDTSC</a></code>
          </td>
	</tr>
      </tbody>

      <tbody>
	<tr id="column_x">
	  <td rowspan="2"><abbr>x</abbr></td>
	  <td>Lock Prefix</td>
	  <td>
<code>L</code> indicates that the instruction is
	  basically valid with <code><a href="http://ref.x86asm.net/geek.html#xF0">F0&nbsp;LOCK</a></code> prefix.
          <code><a href="http://ref.x86asm.net/geek.html#x00">00&nbsp;ADD</a></code>
          </td>
	</tr>
	<tr>
	  <td>
<abbr>FPU</abbr>&nbsp;Push/ <abbr>FPU</abbr>&nbsp;Pop</td>
	  <td>The following codes apply only to x87 <abbr>FPU</abbr>
	  instructions (none of them can use <code>LOCK</code> prefix).
            <ul>
	      <li>
<code>s</code> incidates that the opcode performs
	      additional pu<strong>s</strong>h of a value to the register stack.
              <code><a href="http://ref.x86asm.net/geek.html#xD9_0">D9&nbsp;/0&nbsp;FLD</a></code>
              </li>
	      <li>
<code>p</code> incidates that the opcode performs
	      additional <strong>p</strong>op of the register stack.
              <code><a href="http://ref.x86asm.net/geek.html#xD9_3">D9&nbsp;/3&nbsp;FSTP</a></code>
              </li>
	      <li>
<code>P</code> incidates the same like
	      <code>p</code>, but pops twice.
              <code><a href="http://ref.x86asm.net/geek.html#xD9_3">DA&nbsp;/5&nbsp;FUCOMPP</a></code>
              </li>
	    </ul>
          </td>
	</tr>
      </tbody>

      <tbody>
	<tr id="column_mnemonic">
	  <td rowspan="2">mnemonic</td>
	  <td rowspan="2">Instr. Mnemonic</td>
	  <td>The instruction mnemonic itself. If there is no
	  mnemonic, it holds additional information about the mnemonic
	  or instruction:
            <ul>
	      <li>If the mnemonic is set up using italic, there is no
	        oficial mnemonic and the present one is just suggested
	        one.
                <code><a href="http://ref.x86asm.net/geek.html#xD4">D4&nbsp;AMX</a></code>,
                <code><a href="http://ref.x86asm.net/geek.html#xD5">D5&nbsp;ADX</a></code>,
                <code><a href="http://ref.x86asm.net/geek.html#x0FB9">0FB9&nbsp;UD</a></code>
              </li>
	      <li>
<dfn>no&nbsp;mnemonic</dfn> means that there is no
	      mnemonic for the opcode.
              <code><a href="http://ref.x86asm.net/geek.html#x66">66</a></code>
              </li>
	      <li>
<dfn>invalid</dfn> means that the opcode is invalid. This
	      option is not used everywhere the opcode is invalid, but
	      only in some cases.
              <code><a href="http://ref.x86asm.net/geek.html#x06">06&nbsp;(64-bit mode)</a></code> 
              </li>
	      <li>
<dfn>undefined</dfn> means that the behaviour of the
	      instruction is according to official documentation
	      undefined.
              <code><a href="http://ref.x86asm.net/geek.html#xD6">D6</a></code>
              </li>
	      <li>
<dfn>nop</dfn> means that the opcode is
	      treated as integer <code>NOP</code> instruction. It should
	      contain a reference to description of the source.
              <code><a href="http://ref.x86asm.net/geek.html#x90">no&nbsp;mnenonic&nbsp;nop</a></code>
              </li>
	      <li>
<dfn>null</dfn> means that the prefix has no meaning
	      (no operation).
              <code><a href="http://ref.x86asm.net/geek.html#x26">26&nbsp;(64-bit mode)</a></code>
              </li>
	    </ul>
            
	    If there is a mnemonic, it can hold additional
	    attributes of the instruction:
            <ul>
	      <li>
<dfn>nop</dfn> means that the instruction is
	      treated as integer <code>NOP</code> instruction (except
	      <code>NOP</code> instructions themselves). It should
	      contain a reference to description of the source.
              <code><a href="http://ref.x86asm.net/geek.html#DB_4">DBE0</a>&nbsp;FNENI</code>
              </li>
	    </ul>
          </td>
	</tr>
	<tr>
          <td>Only geek's editions:
            <ul>
	      <li>
<dfn>alias</dfn> means that the opcode is an alias
	      to another opcode. The attribute should be a reference
	      to that instruction.
                <code><a href="http://ref.x86asm.net/geek.html#x82">group 82</a></code>,
	        <code><a href="http://ref.x86asm.net/geek.html#xC0_6">C0&nbsp;/6&nbsp;SAL</a></code>
              </li>
	      <li>
<dfn>part alias</dfn> means not true alias. It
	      should contain a reference to the description of the
	      differences between referenced instructions.
              <code><a href="http://ref.x86asm.net/geek.html#xF1">F1&nbsp;INT1</a></code>
              </li>
	    </ul>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_op">
	  <td>
<abbr>op1</abbr>, <abbr>op2</abbr>, ...</td>
	  <td>Instr. Operands</td>
	  <td>Instruction operands. Geek's editions use special
	  operand codes, explained in <a href="#Instruction-Operand-Codes">Instruction Operand Codes</a>
	  chapter below. If an operand is set up using italic, it is an
	  implicit operand, which is not explicitly used. If an operand is set up using
	  boldface, it is modified by the instruction.</td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_iext">
	  <td><abbr>iext</abbr></td>
	  <td>Instr. Extension Group</td>
          
	  <td>The instruction extension group, which was the
	  opcode released on:
            <ol>
<li>
<code>MMX</code> <abbr>MMX</abbr> Technology</li>
<li>
<code>SSE1</code> Streaming <abbr>SIMD</abbr> Extensions&nbsp;(1)</li>
<li>
<code>SSE2</code> Streaming <abbr>SIMD</abbr> Extensions&nbsp;2</li>
<li>
<code>SSE3</code> Streaming <abbr>SIMD</abbr> Extensions&nbsp;3</li>
<li>
<code>SSSE3</code> Supplemental Streaming <abbr>SIMD</abbr> Extensions&nbsp;3</li>
<li>
<code>SSE41</code> Streaming <abbr>SIMD</abbr> Extensions&nbsp;4.1</li>
<li>
<code>SSE42</code> Streaming <abbr>SIMD</abbr> Extensions&nbsp;4.2</li>
<li>
<code>VMX</code> Virtualization Technology Extensions</li>
	      <li>
<code>SMX</code> Safer Mode Extensions</li>
	    </ol>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_grp1_grp2_grp3">
	  <td>
<abbr>grp1</abbr>, <abbr>grp2</abbr>, <abbr>grp3</abbr>
</td>
	  <td>Main Group, Sub-group, Sub -sub-group</td>
	  <td>These columns are present only in geek's editions. They
	  classifies the instruction among groups. These groups
	  don't match the instruction groups given by the Intel
	  manual (I found them too loose). One instruction may fit
	  into more groups.
            <ol>
	      <li>
<dfn>prefix</dfn>
                <ol>
		  <li>
<dfn>segreg</dfn> segment register</li>
		  <li>
<dfn>branch</dfn>
		    <ol>
		      <li>
<dfn>cond</dfn> conditional</li>
		    </ol>
                  </li>
		  <li>
<dfn>x87fpu</dfn>
                    <ol>
		      <li>
<dfn>control</dfn> (only <code><a href="http://ref.x86asm.net/geek.html#x9B">WAIT</a></code>)</li>
		    </ol>
                  </li>
		</ol>
              </li>
	      <li>
<dfn>obsol</dfn> obsolete
                <ol>
		  <li><dfn>control</dfn></li>
		</ol>
              </li>
	      <li>
<dfn>gen</dfn> general
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li><dfn>stack</dfn></li>
		  <li>
<dfn>conver</dfn> type conversion</li>
		  <li>
<dfn>arith</dfn> arithmetic
                    <ol>
		      <li><dfn>binary</dfn></li>
		      <li><dfn>decimal</dfn></li>
		    </ol>
                  </li>
		  <li><dfn>logical</dfn></li>
		  <li>
<dfn>shftrot</dfn> shift&amp;rotate</li>
		  <li>
<dfn>bit</dfn> bit manipulation</li>
		  <li>
<dfn>branch</dfn>
		    <ol>
		      <li>
<dfn>cond</dfn> conditional</li>
		    </ol>
                  </li>
		  <li>
<dfn>break</dfn> interrupt</li>
		  <li>
<dfn>string</dfn> (means that the instruction can make use of the <a href="http://ref.x86asm.net/geek.html#xF2">REP family prefixes</a>)</li>
		  <li>
<dfn>inout</dfn> I/O</li>
		  <li>
<dfn>flgctrl</dfn> flag control</li>
		  <li>
<dfn>segreg</dfn> segment register manipulation</li>
		  <li><dfn>control</dfn></li>
		</ol>
              </li>
	      <li>system
                <ol>
		  <li>
<dfn>branch</dfn>
                    <ol>
		      <li>
<dfn>trans</dfn> transitional (implies
		      sensitivity to operand-size attribute)</li>
		    </ol>
                  </li>
		  
		</ol>
              </li>
	      <li>
<dfn>x87fpu</dfn> <abbr>x87&nbsp;FPU</abbr>
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li>
<dfn>arith</dfn> basic arithmetic</li>
		  <li>
<dfn>compar</dfn> comparison</li>
		  <li>
<dfn>trans</dfn> transcendental</li>
		  <li>
<dfn>ldconst</dfn> load constant</li>
		  <li><dfn>control</dfn></li>
		  <li>
<dfn>conv</dfn> conversion</li>
		</ol>
              </li>
	      <li>
<dfn>sm</dfn> <abbr>x87&nbsp;FPU</abbr> and
	      <abbr>SIMD</abbr> state management
              </li>
	    </ol>
<code>MMX</code> instruction extensions technology groups. Note that
these groups are just experimental and may change in future.
            <ol>
	      <li>
<dfn>datamov</dfn> data movement</li>
	      <li>
<dfn>arith</dfn> packed arithmetic</li>
	      <li>
<dfn>compar</dfn> comparison</li>
	      <li>
<dfn>conver</dfn> conversion</li>
	      <li><dfn>logical</dfn></li>
	      <li><dfn>shift</dfn></li>
	      <li>
<dfn>unpack</dfn> unpacking</li>

	    </ol>
<code>SSE1</code> instruction extensions groups. Note that
these groups are just experimental and may change in future.
            <ol>
	      <li>
<dfn>simdfp</dfn> <abbr>SIMD</abbr> single-precision
	      floating-point
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>

		  <li>
<dfn>arith</dfn> packed arithmetic</li>
		  <li>
<dfn>compar</dfn> comparison</li>
		  <li><dfn>logical</dfn></li>
		  <li>
<dfn>shunpck</dfn> shuffle&amp;unpacking</li>
		</ol>
	      </li>
	      <li>
<dfn>conver</dfn> conversion instructions</li>
	      <li>
<dfn>simdint</dfn> 64-bit <abbr>SIMD</abbr> integer






              </li>
	      <li>
<dfn>mxcsrsm</dfn> <code>MXCSR</code> state management</li>
	      <li>
<dfn>cachect</dfn> cacheability control</li>

	      <li>
<dfn>fetch</dfn> prefetch</li>
	      <li>
<dfn>order</dfn> instruction ordering</li>
	    </ol>

            <code>SSE2</code> instruction extensions groups. Note that
            these groups are just experimental and may change in future.

            <ol>
	      <li>
<dfn>pcksclr</dfn> packed and scalar
	      double-precision floating-point
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li>
<dfn>conver</dfn> conversion</li>
		  <li>
<dfn>arith</dfn> packed arithmetic</li>
		  <li>
<dfn>compar</dfn> comparison</li>
		  <li><dfn>logical</dfn></li>
		  <li>
<dfn>shunpck</dfn> shuffle&amp;unpacking</li>
		</ol>
	      </li>
	      <li>
<dfn>pcksp</dfn> packed single-precision floating-point</li>
	      <li>
<dfn>simdint</dfn> 128-bit <abbr>SIMD</abbr> integer
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li>
<dfn>arith</dfn> packed arithmetic</li>
		  <li>
<dfn>shunpck</dfn> shuffle&amp;unpacking</li>
		  <li><dfn>shift</dfn></li>
		  <li>
<dfn>compar</dfn> comparison</li>
		  <li>
<dfn>conver</dfn> conversion</li>
		  <li><dfn>logical</dfn></li>
		</ol>
              </li>

	      <li>
<dfn>cachect</dfn> cacheability control</li>
	      <li>
<dfn>order</dfn> instruction ordering</li>
	    </ol>

            <code>SSE3</code> instruction extensions groups. Note that
            these groups are just experimental and may change in
            future.

            <ol>
	      <li>
<dfn>simdfp</dfn> <abbr>SIMD</abbr> single-precision
	      floating-point (<abbr>SIMD</abbr> packed)
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li>
<dfn>arith</dfn> packed arithmetic</li>
		</ol>
              </li>


	      <li>
<dfn>cachect</dfn> cacheability control</li>
	      <li>
<dfn>sync</dfn> agent synchronization</li>
	    </ol>

            <code>SSSE3</code> instruction extensions group. Note that
            these groups are just experimental and may change in future.

            <ol>
	      <li>
<dfn>simdint</dfn> <abbr>SIMD</abbr> integer</li>
	    </ol>

            <code>SSE4.1</code> instruction extensions group. Note that
            these groups are just experimental and may change in
            future.

            <ol>
	      <li>
<dfn>simdint</dfn> <abbr>SIMD</abbr> integer
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li>
<dfn>arith</dfn> packed arithmetic</li>
		  <li>
<dfn>compar</dfn> comparison</li>
		  <li>
<dfn>conver</dfn> conversion</li>
		</ol>
              </li>

	      <li>
<dfn>simdfp</dfn> <abbr>SIMD</abbr> <abbr>SIMD</abbr> floating-point
                <ol>
		  <li>
<dfn>datamov</dfn> data movement</li>
		  <li>
<dfn>arith</dfn> packed arithmetic</li>
		  <li>
<dfn>conver</dfn> conversion</li>
		</ol>
              </li>

	      <li>
<dfn>cachect</dfn> cacheability control</li>
	    </ol>

            <code>SSE4.2</code> instruction extensions group. Note that
            these groups are just experimental and may change in
            future.

            <ol>
	      <li>
<dfn>simdint</dfn> <abbr>SIMD</abbr> integer
                <ol>
		  <li>
<dfn>compar</dfn> comparison</li>
		</ol>
              </li>

	      <li>
<dfn>strtxt</dfn> string and text processing</li>
	    </ol>

            <code>VMX</code> and <code>SMX</code> instruction
            extensions has no groups at the moment. The grouping may
            be added in future.

          </td>
	</tr>
      </tbody>

      <tbody>
	<tr id="column_tested_f_modif_f_def_f_undef_f">
	  <td>tested&nbsp;f, modif&nbsp;f, def&nbsp;f, undef&nbsp;f</td>
	  <td>Tested, Modified, Defined, and Undefined Flags</td>
	  <td>
            <ul>
	      <li>For <code>rFlags</code> register, indicates these
	       flags using <dfn>odiszapc</dfn> pattern. Present flag
	       fits in with the appropriate group.
              <code><a href="http://ref.x86asm.net/geek.html#xC0">group&nbsp;C0</a></code>
             </li>
	      <li>For <abbr>x87&nbsp;FPU</abbr> flags, indicates these
	        flags using <dfn>1234</dfn> <abbr>x87&nbsp;FPU</abbr>
	        flag pattern. Present flag
	        fits in with the appropriate group.
                <code><a href="http://ref.x86asm.net/geek.html#DB_7">DB/7</a>&nbsp;FSTP</code>
              </li>
	    </ul>
          Note that if a flag is present in both Defined and
	  Undefined column, the flag fits in under further conditions,
	  which are not described by this reference.
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_f_values">
	  <td>f&nbsp;values</td>
	  <td>Flags Values</td>
	  <td>
            <ul>
	      <li>For <code>rFlags</code> register, indicates the values of flags, which are always
                set or cleared, using case-sensitive <dfn>odiszapc</dfn> flag
                pattern. Lower-case flag means cleared flag,
                upper-case means set flag.
                <code><a href="http://ref.x86asm.net/geek.html#xF9">STC</a></code>
              </li>
              
	      <li>For <abbr>x87&nbsp;FPU</abbr> flags, indicates these
                flags using <dfn>1234</dfn> <abbr>x87&nbsp;FPU</abbr>
	        flag pattern. Present flag holds its value.
                <code><a href="http://ref.x86asm.net/geek.html#DB_4">DBE3</a>&nbsp;FNINIT</code>
              </li>
	    </ul>
          </td>
	</tr>
      </tbody>
      <tbody>
	<tr id="column_description_notes">
	  <td>description, notes</td>
	  <td></td>
	  <td>Short desciption of the opcode. For now, the descriptions
	  are very general. They will be improved in future perhaps.</td>
	</tr>
      </tbody>
    </table><p></p>
<h2 id="Instruction-Operand-Codes">Instruction Operand Codes</h2>
<p>These codes come from official codes used in Intel
  manual Instruction Set Reference,&nbsp;N-Z for Pentium&nbsp;4 processor,
  revision&nbsp;17. The reason of using this particular, out-of-date
  revision is that the codes from this revision
  are most apposite ones. In next revisions the codes changed
  unfortunately. These codes were modified and completed mainly because
  of the possibility to code operands simultaneously for 64-bit
  mode. Ideally, it would be the best to make brand new codes, but I'm
  afraid those wouldn't be widely acceptable.</p>
<p>The State column says if the code is
  original, added or changed.</p>
<p>The "Geek" part in these tables in the first column indicates
  codes used in <abbr>HTML</abbr> geek's editions and in the <a href="#Source_XML_Document_desc">source XML
  document</a> as well. The "Coder" part indicates
  alternative codes used in <abbr>HTML</abbr> coder's editions. These
  are used also within instruction reference in Intel manual.</p>
<h3>Codes for Addressing Method</h3>
<p>The following abbreviations are used for addressing methods:
    </p><table cellpadding="6">
      <thead>
	<tr>
	  <th>Geek</th>
<th rowspan="2">State</th>
<th rowspan="2">Description</th>
	</tr>
	<tr>
	  <th>Coder</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><code>A</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Direct address. The instruction has no ModR/M byte; the address of the operand is encoded
in the instruction; no base register, index register, or scaling factor can be applied
(for example, far <code>JMP</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#xEA">EA</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>ptr</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>BA</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Memory addressed by <code>DS:EAX</code>, or
	  by <code>rAX</code> in 64-bit mode (only
	  <code><a href="http://ref.x86asm.net/geek.html#x0F01_1">0F01C8&nbsp;MONITOR</a></code>).
          </td>
	</tr>
	<tr>
	  <td><code>m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>BB</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Memory addressed by <code>DS:eBX+AL</code>, or by <code>rBX+AL</code> in 64-bit
	  mode (only
	  <code><a href="http://ref.x86asm.net/geek.html#xD7">XLAT</a></code>).
          (This code changed from single <code>B</code> in revision 1.00)
          </td>
	</tr>
	<tr>
	  <td><code>m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>BD</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Memory addressed by <code>DS:eDI</code>
	  or by <code>RDI</code> (only <code><a href="http://ref.x86asm.net/geek.html#x0FF7">0FF7</a>&nbsp;MASKMOVQ</code> and
	  <code><a href="http://ref.x86asm.net/geek.html#x0FF7">660FF7</a>&nbsp;MASKMOVDQU</code>) (This
	  code changed from <code>YD</code> (introduced in 1.00) in
	  revision 1.02)
          </td>
	</tr>
	<tr>
	  <td><code>m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>C</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a control
	  register (only <code>MOV</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x0F20">0F20</a></code>,&nbsp;<code><a href="http://ref.x86asm.net/geek.html#x0F22">0F22</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>CRn</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>D</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a debug
	  register (only <code>MOV</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x0F21">0F21</a></code>,&nbsp;<code><a href="http://ref.x86asm.net/geek.html#x0F23">0F23</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>DRn</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>E</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">A ModR/M byte follows the opcode and specifies the operand. The operand is either a
	general-purpose register or a memory address. If it is a memory address, the address is
	computed from a segment register and any of the following values: a base register, an
	index register, a scaling factor, or a displacement.</td>
	</tr>
	<tr>
	  <td><code>r/m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>ES</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">(Implies original <code>E</code>). A ModR/M
	  byte follows the opcode and specifies the operand. The
	  operand is either a
	  x87 <abbr>FPU</abbr> stack register or a memory address. If it is a memory address, the address is
	  computed from a segment register and any of the following values: a base register, an
	  index register, a scaling factor, or a displacement.
          </td>
	</tr>
	<tr>
	  <td><code>STi/m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>EST</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">(Implies original <code>E</code>). A ModR/M
	  byte follows the opcode and specifies the x87
	  <abbr>FPU</abbr> stack register.
          </td>
	</tr>
	<tr>
	  <td><code>STi</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>F</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">rFLAGS register.</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>G</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a general
	  register (for example, <code>AX</code>&nbsp;(<code>000</code>)).</td>
	</tr>
	<tr>
	  <td><code>r</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>H</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">The r/m field of the ModR/M byte always selects
	  a general register, regardless of the mod field (for
	  example, <code>MOV</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x0F20">0F20</a></code>)).</td>
	</tr>
	<tr>
	  <td>r</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>I</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Immediate data. The operand value is encoded in subsequent bytes of the instruction.</td>
	</tr>
	<tr>
	  <td><code>imm</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>J</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The instruction contains a relative offset to be added to the instruction pointer register
(for example, <code>JMP</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#xE9">E9</a></code>),
	  <code><a href="http://ref.x86asm.net/geek.html#xE2">LOOP</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>rel</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>M</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The ModR/M byte may refer only to memory: mod&nbsp;!=&nbsp;11bin
	  (<code><a href="http://ref.x86asm.net/geek.html#x62">BOUND</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#x8D">LEA</a></code>,
          <code><a href="http://ref.x86asm.net/geek.html#xFF_3">CALLF</a></code>,
          <code><a href="http://ref.x86asm.net/geek.html#xFF_5">JMPF</a></code>,
          <code><a href="http://ref.x86asm.net/geek.html#xC4">LES</a></code>, <code><a href="http://ref.x86asm.net/geek.html#xC5">LDS</a></code>, <code><a href="http://ref.x86asm.net/geek.html#x0FB2">LSS</a></code>, <code><a href="http://ref.x86asm.net/geek.html#x0FB4">LFS</a></code>, <code><a href="http://ref.x86asm.net/geek.html#x0FB5">LGS</a></code>, <code><a href="http://ref.x86asm.net/geek.html#x0FC7_1">CMPXCHG8B</a></code>, <code><a href="http://ref.x86asm.net/geek.html#x0FC7_1">CMPXCHG16B</a></code>,
          <code><a href="http://ref.x86asm.net/geek.html#x0FF0">F20FF0</a>&nbsp;LDDQU</code>).</td>
	</tr>
	<tr>
	  <td><code>m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>N</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The R/M field of the ModR/M byte selects a packed
	  quadword <abbr>MMX</abbr> technology register.</td>
	</tr>
	<tr>
	  <td><code>mm</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>O</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The instruction has no ModR/M byte; the offset of the operand is coded as a word,
	double word or quad word (depending on address size attribute) in the instruction. No base register,
	index register, or scaling factor can be applied (only <code>MOV</code>&nbsp;
	  (<code><a href="http://ref.x86asm.net/geek.html#xA0">A0</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#xA1">A1</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#xA2">A2</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#xA3">A3</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>moffs</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>P</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a packed
	  quadword <abbr>MMX</abbr> technology register.</td>
	</tr>
	<tr>
	  <td><code>mm</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>Q</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">A ModR/M byte follows the opcode and specifies the operand. The operand is either
an <abbr>MMX</abbr> technology register or a memory address. If it is a memory address, the address
is computed from a segment register and any of the following values: a base register,
an index register, a scaling factor, and a displacement.</td>
	</tr>
	<tr>
	  <td><code>mm/m64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>R</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The mod field of the ModR/M byte may refer only to a general register (only
<code>MOV</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x0F20">0F20</a></code>-<code><a href="http://ref.x86asm.net/geek.html#x0F24">0F24</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#x0F26">0F26</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>r</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>S</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a segment
	  register (only <code>MOV</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x8C">8C</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#x8E">8E</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>Sreg</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>SC</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Stack operand, used by instructions which
	  either push an operand to the stack or pop an operand
	  from the stack. Pop-like instructions are, for example,
	  <code>POP</code>, <code>RET</code>, <code>IRET</code>,
	  <code>LEAVE</code>. Push-like are, for example,
	  <code>PUSH</code>, <code>CALL</code>, <code>INT</code>.
          No Operand type is provided along with this method because it
	  depends on source/destination operand(s).</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>T</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a test register
	  (only <code>MOV</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x0F24">0F24</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#x0F26">0F26</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>TRn</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>U</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The R/M field of the ModR/M byte selects a 128-bit <abbr>XMM</abbr> register.</td>
	</tr>
	<tr>
	  <td><code>xmm</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>V</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">The reg field of the ModR/M byte selects a 128-bit <abbr>XMM</abbr> register.</td>
	</tr>
	<tr>
	  <td><code>xmm</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>W</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">A ModR/M byte follows the opcode and specifies the operand. The operand is either a
128-bit <abbr>XMM</abbr> register or a memory address. If it is a memory address, the address is
computed from a segment register and any of the following values: a base register, an
index register, a scaling factor, and a displacement</td>
	</tr>
	<tr>
	  <td><code>xmm/m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>X</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Memory addressed by the <code>DS:eSI</code> or by
	  <code>RSI</code> (only <code><a href="http://ref.x86asm.net/geek.html#xA4">MOVS</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#xA6">CMPS</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#x6E">OUTS</a></code>, and
	  <code><a href="http://ref.x86asm.net/geek.html#xAC">LODS</a></code>). In
	  64-bit mode, only 64-bit (<code>RSI</code>) and 32-bit
	  (<code>ESI</code>) address sizes are supported. In
	  non-64-bit modes, only 32-bit (<code>ESI</code>) and 16-bit
	  (<code>SI</code>) address sizes are supported.</td>
	</tr>
	<tr>
	  <td><code>m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>Y</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Memory addressed by the <code>ES:eDI</code> or by
	  <code>RDI</code> (only <code><a href="http://ref.x86asm.net/geek.html#xA4">MOVS</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#xA6">CMPS</a></code>,
	  <code><a href="http://ref.x86asm.net/geek.html#x6C">INS</a></code>,
<code><a href="http://ref.x86asm.net/geek.html#xAA">STOS</a></code>, and
	  <code><a href="http://ref.x86asm.net/geek.html#xAE">SCAS</a></code>). In
	  64-bit mode, only 64-bit (<code>RDI</code>) and 32-bit
	  (<code>EDI</code>) address sizes are supported. In
	  non-64-bit modes, only 32-bit (<code>EDI</code>) and
	  16-bit (<code>DI</code>) address sizes are supported. The
	  implicit <code>ES</code> segment register cannot be overriden by
	  a segment prefix.</td>
	</tr>
	<tr>
	  <td><code>m</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>Z</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">The instruction has no ModR/M byte; the three
	  least-significant bits of the opcode byte selects
	  a general-purpose register</td>
	</tr>
	<tr>
	  <td><code>r</code></td>
	</tr>
      </tbody>
    </table><p></p>
<p>The following abbreviations are used for addressing
  methods only in case of direct segment registers and are accessible
  only in <abbr>HTML</abbr> geek's editions as segment register's
  title. As for <a href="#Source_XML_Document_desc">source XML document</a>, they are used within
  <dfn>address</dfn> atribute of <dfn>syntax/dst</dfn> or
  <dfn>syntax/src</dfn> elements. All of them are added:

    </p><table cellpadding="6">
      <tbody>
	<tr>
	  <td><code>S2</code></td>
	  <td>The two bits at bit index three of the opcode byte
	  selects one of original four segment registers (for example,
	  <code><a href="http://ref.x86asm.net/geek.html#x06">PUSH&nbsp;ES</a></code>).</td>
	</tr>
	<tr>
	  <td><code>S30</code></td>
	  <td>The three least-significant bits of the opcode byte
	  selects segment register <code>SS</code>, <code>FS</code>, or
	  <code>GS</code> (for example, <code><a href="http://ref.x86asm.net/geek.html#x0FB2">LSS</a></code>).</td>
	</tr>
	<tr>
	  <td><code>S33</code></td>
	  <td>The three bits at bit index three of the opcode byte
	  selects segment register <code>FS</code> or <code>GS</code>
	  (for example, <code><a href="http://ref.x86asm.net/geek.html#x0FA0">PUSH&nbsp;FS</a></code>).
	  </td>
	</tr>
      </tbody>
    </table><p></p>
<h3>Codes for Operand Type</h3>
<p>The following abbreviations are used for operand
  types:
    </p><table cellpadding="6">
      <thead>
	<tr>
	  <th>Geek</th>
<th rowspan="2">State</th>
<th rowspan="2">Description</th>
	</tr>
	<tr>
	  <th>Coder</th>
	</tr>
      </thead>
      <tbody>
	<tr>
	  <td><code>a</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Two one-word operands in memory or two double-word operands in memory, depending
on operand-size attribute (only <code><a href="http://ref.x86asm.net/geek.html#x62">BOUND</a></code>).</td>
	</tr>
	<tr>
	  <td><code>16/32&amp;16/32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>b</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Byte, regardless of operand-size attribute.</td>
	</tr>
	<tr>
	  <td><code>8</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>bcd</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Packed-<abbr>BCD</abbr>. Only x87 <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xDF_4">FBLD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>80dec</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>bs</code></td>
	  <td rowspan="2">Added; simplified <code>bsq</code>
</td>
	  <td rowspan="2">Byte, sign-extended to the size of the destination operand.</td>
	</tr>
	<tr>
	  <td><code>8</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>bsq</code></td>
	  <td rowspan="2">Original; replaced by <code>bs</code>
</td>
	  <td rowspan="2">(Byte, sign-extended to 64 bits.)</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>bss</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Byte, sign-extended to the size of the stack pointer (for
	  example, <code>PUSH</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x6A">6A</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>8</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>c</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Byte or word, depending on operand-size
	  attribute. (unused even by Intel?)</td>
	</tr>
	<tr>
	  <td>?</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>d</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Doubleword, regardless of operand-size attribute.</td>
	</tr>
	<tr>
	  <td><code>32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>di</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Doubleword-integer. Only x87
	  <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xDA_0">FIADD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>32int</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>dq</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Double-quadword, regardless of operand-size attribute
	  (for example, <code><a href="http://ref.x86asm.net/geek.html#x0FC7_1">CMPXCHG16B</a></code>).</td>
	</tr>
	<tr>
	  <td><code>128</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>dqp</code></td>
	  <td rowspan="2">Added; combines <code>d</code> and <code>qp</code>
</td>
	  <td rowspan="2">Doubleword, or quadword, promoted by <code><a href="http://ref.x86asm.net/geek.html#x48">REX.W</a></code> in
	  64-bit mode (for example, <code><a href="http://ref.x86asm.net/geek.html#x63">MOVSXD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>32/64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>dr</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Double-real. Only x87 <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xDC_0">FADD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>64real</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>ds</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Doubleword, sign-extended to 64 bits (for example,
	  <code>CALL</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#xE8">E8</a></code>).</td>
	</tr>
	<tr>
	  <td><code>32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>e</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">x87 <abbr>FPU</abbr> environment (for example, <code><a href="http://ref.x86asm.net/geek.html#xD9_6">FSTENV</a></code>).</td>
	</tr>
	<tr>
	  <td><code>14/28</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>er</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Extended-real. Only x87 <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xDB_5">FLD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>80real</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>p</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">32-bit or 48-bit pointer, depending on operand-size
	  attribute (for example, <code>CALLF</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x9A">9A</a></code>).</td>
	</tr>
	<tr>
	  <td><code>16:16/32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>pi</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Quadword MMX technology data. </td>
	</tr>
	<tr>
	  <td>(<code>64</code>)</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>pd</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">128-bit packed double-precision floating-point data.</td>
	</tr>
	<tr>
	  <td>&nbsp;</td> 
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>ps</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">128-bit packed single-precision floating-point data.</td>
	</tr>
	<tr>
	  <td>(<code>128</code>)</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>psq</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">64-bit packed single-precision floating-point data.</td>
	</tr>
	<tr>
	  <td><code>64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>pt</code></td>
	  <td rowspan="2">Original; replaced by <code>ptp</code>
</td>
	  <td rowspan="2">(80-bit far pointer.)</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>ptp</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">32-bit or 48-bit pointer, depending on operand-size
	  attribute, or 80-bit far pointer, promoted by <code><a href="http://ref.x86asm.net/geek.html#x48">REX.W</a></code>
	  in 64-bit mode (for example,
	  <code>CALLF</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#xFF_3">FF&nbsp;/3</a></code>)).
	  </td>
	</tr>
	<tr>
	  <td><code>16:16/32/64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>q</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Quadword, regardless of operand-size attribute (for
	  example, <code>CALL</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#xFF_2">FF&nbsp;/2</a></code>)).
	  </td>
	</tr>
	<tr>
	  <td><code>64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>qi</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Qword-integer. Only x87 <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xDF_5">FILD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>64int</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>qp</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Quadword, promoted by <code><a href="http://ref.x86asm.net/geek.html#x48">REX.W</a></code> (for
	  example, <code><a href="http://ref.x86asm.net/geek.html#xCF">IRETQ</a></code>).</td>
	</tr>
	<tr>
	  <td><code>64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>s</code></td>
	  <td>Changed to</td>
	  <td>6-byte pseudo-descriptor, or 10-byte pseudo-descriptor
	  in 64-bit mode (for example, <code><a href="http://ref.x86asm.net/geek.html#x0F01_0">SGDT</a></code>).</td>
	</tr>
	<tr>
	  <td>-</td>
	  <td>Changed from</td>
	  <td><cite>6-byte pseudo-descriptor.</cite></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>sd</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Scalar element of a 128-bit packed double-precision floating data.</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>si</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Doubleword integer register (e.&nbsp;g.,
	  <code>eax</code>). (unused even by Intel?)</td>
	</tr>
	<tr>
	  <td>?</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>sr</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Single-real. Only x87 <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xD8_0">FADD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>32real</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>ss</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Scalar element of a 128-bit packed single-precision floating data.</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>st</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">x87 <abbr>FPU</abbr> state (for example, <code><a href="http://ref.x86asm.net/geek.html#xDD_6">FSAVE</a></code>).</td>
	</tr>
	<tr>
	  <td><code>94/108</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>stx</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">x87 <abbr>FPU</abbr> and <abbr>SIMD</abbr> state (<code><a href="http://ref.x86asm.net/geek.html#x0FAE_0">FXSAVE</a></code>
	  and <code><a href="http://ref.x86asm.net/geek.html#x0FAE_1">FXRSTOR</a></code>).</td>
	</tr>
	<tr>
	  <td><code>512</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>t</code></td>
	  <td rowspan="2">Original; replaced by <code>ptp</code>
</td>
	  <td rowspan="2">10-byte far pointer.</td>
	</tr>
	<tr>
	  <td>-</td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>v</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Word or doubleword, depending on operand-size attribute
	  (for example, <code>INC</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x40">40</a></code>),
	  <code>PUSH</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x50">50</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>16/32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>vds</code></td>
	  <td rowspan="2">Added; combines <code>v</code> and <code>ds</code>
</td>
	  <td rowspan="2">Word or doubleword, depending on operand-size attribute,
	or doubleword, sign-extended to 64 bits for 64-bit operand size.</td>
	</tr>
	<tr>
	  <td><code>16/32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>vq</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Quadword (default) or word if operand-size prefix is used (for example,
	  <code>PUSH</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x50">50</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>64/16</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>vqp</code></td>
	  <td rowspan="2">Added; combines <code>v</code> and <code>qp</code>
</td>
	  <td rowspan="2">Word or doubleword, depending on operand-size attribute, or quadword, promoted by <code><a href="http://ref.x86asm.net/geek.html#x48">REX.W</a></code> in 64-bit mode.</td>
	</tr>
	<tr>
	  <td><code>16/32/64</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>vs</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Word or doubleword sign extended to the size of the
	  stack pointer (for example, <code>PUSH</code>&nbsp;(<code><a href="http://ref.x86asm.net/geek.html#x68">68</a></code>)).</td>
	</tr>
	<tr>
	  <td><code>16/32</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>w</code></td>
	  <td rowspan="2">Original</td>
	  <td rowspan="2">Word, regardless of operand-size attribute (for example, <code><a href="http://ref.x86asm.net/geek.html#xC8">ENTER</a></code>).</td>
	</tr>
	<tr>
	  <td><code>16</code></td>
	</tr>
      </tbody>
      <tbody>
	<tr>
	  <td><code>wi</code></td>
	  <td rowspan="2">Added</td>
	  <td rowspan="2">Word-integer. Only x87 <abbr>FPU</abbr> instructions (for example, <code><a href="http://ref.x86asm.net/geek.html#xDE_0">FIADD</a></code>).</td>
	</tr>
	<tr>
	  <td><code>16int</code></td>
	</tr>
      </tbody>
    </table><p></p>
<p>The following abbreviations are used for operand
  types and are accessible only in <abbr>HTML</abbr> geek's editions
  as operand's code title. They are issued to indicate
  a dependency on address-size attribute instead of operand-size
  attribute. As for <a href="#Source_XML_Document_desc">source XML document</a>, they are used within
  <dfn>address</dfn> atribute of <dfn>syntax/dst</dfn> or
  <dfn>syntax/src</dfn> elements. All of them are added:

    </p><table cellpadding="6">
      <tbody>
        
        
	<tr>
	  <td><code>va</code></td>
	  <td>Word or doubleword, according to address-size attribute (only <code><a href="http://ref.x86asm.net/geek.html#xF2">REP</a></code> and <code><a href="http://ref.x86asm.net/geek.html#xE0">LOOP</a></code> families).</td>
	</tr>
	<tr>
	  <td><code>dqa</code></td>
	  <td>Doubleword or quadword, according to address-size attribute (only <code><a href="http://ref.x86asm.net/geek.html#xF2">REP</a></code> and <code><a href="http://ref.x86asm.net/geek.html#xE0">LOOP</a></code> families).</td>
	</tr>
	<tr>
	  <td><code>wa</code></td>
	  <td>Word, according to address-size attribute (only <code><a href="http://ref.x86asm.net/geek.html#xE3">JCXZ</a></code> instruction).</td>
	</tr>
	<tr>
	  <td><code>wo</code></td>
	  <td>Word, according to current operand size (e.&nbsp;g.,
	  <code><a href="http://ref.x86asm.net/geek.html#xA5">MOVSW</a></code> instruction).</td>
	</tr>
	<tr>
	  <td><code>ws</code></td>
	  <td>Word, according to current stack size (only <code><a href="http://ref.x86asm.net/geek64.html#x9C">PUSHF</a></code> and
	  <code><a href="http://ref.x86asm.net/geek64.html#x9D">POPF</a></code> instructions in 64-bit mode).</td>
	</tr>
	<tr>
	  <td><code>da</code></td>
	  <td>Doubleword, according to address-size attribute (only <code><a href="http://ref.x86asm.net/geek.html#xE3">JECXZ</a></code> instruction).</td>
	</tr>
	<tr>
	  <td><code>do</code></td>
	  <td>Doubleword, according to current operand size (e.&nbsp;g.,
	  <code><a href="http://ref.x86asm.net/geek.html#xA5">MOVSD</a></code> instruction).</td>
	</tr>
	<tr>
	  <td><code>qa</code></td>
	  <td>Quadword, according to address-size attribute (only <code><a href="http://ref.x86asm.net/geek.html#xE3">JRCXZ</a></code> instruction).</td>
	</tr>
	<tr>
	  <td><code>qs</code></td>
	  <td>Quadword, according to current stack size (only <code><a href="http://ref.x86asm.net/geek64.html#x9C">PUSHFQ</a></code> and
	  <code><a href="http://ref.x86asm.net/geek64.html#x9D">POPFQ</a></code> instructions).</td>
	</tr>
      </tbody>
    </table><p></p>
<h2 id="Current-State">Current State</h2>
<p>In this version, the reference is almost
  complete. It contains general, system,
  <abbr>x87&nbsp;FPU</abbr>, MMX, <abbr>SSE</abbr>, <abbr>SSE1</abbr>,
  <abbr>SSE2</abbr>, <abbr>SSE3</abbr>, <abbr>SSSE3</abbr>, <abbr>SSE4</abbr>,
  <abbr>VMX</abbr>, and <abbr>SMX</abbr> instructions (both one-byte
  and two-byte ones). We are working on <abbr>AMD</abbr>-specific
  instructions and Intel <abbr>AVX</abbr> instructions now.</p>
<p>The <abbr>MMX</abbr> and <abbr>SSE</abbr>*
  instruction classification among groups is considered experimental
  and may change in future.</p>
<p>Note that from the point of project's progress,
  modifications of any of <abbr>HTML</abbr> editions is almost
  useless. A <abbr>HTML</abbr> edition is just a result of transformation of
  <a onclick="javascript:urchinTracker ('downloads/x86reference.xml');" href="http://ref.x86asm.net/x86reference.xml">source XML file</a>, so
  all modifications need to be done there.</p>
<h2 id="Implementations">Implementations</h2>
<p><a onclick="javascript:urchinTracker ('outgoing/http://sourceforge.net/projects/bukowski/');" href="http://sourceforge.net/projects/bukowski/">Bukowski</a>'s
  disassembler is first public implementation of the <a onclick="javascript:urchinTracker ('outgoing/x86reference.xml');" href="http://ref.x86asm.net/x86reference.xml">XML&nbsp;reference</a>.</p>
<p><a onclick="javascript:urchinTracker ('outgoing/http://sourceforge.net/projects/mediana/');" href="http://sourceforge.net/projects/mediana/">Mediana</a>,
  maintained by Mikae, is table-based x86/x86-64 disassembler
  engine. However, the transformation from <a onclick="javascript:urchinTracker ('downloads/x86reference.xml');" href="http://ref.x86asm.net/x86reference.xml">source XML file</a> is not
  a part of the project.</p>
<h2 id="License">License</h2>
<p>Since version 1.12, the reference is licensed under GPL-3.0.
  For more see its
  <a onclick="javascript:urchinTracker ('outgoing/https://github.com/Barebit/x86reference');" href="https://github.com/Barebit/x86reference">GitHub repository</a>.
  </p>
<p>The old license (used up to version 1.12) is not available anymore.</p>
<h2 id="Resources">Resources</h2>
<p>This reference has been completed using the
  following resources:</p>
<p><a href="http://x86asm.net/links/index.html#intel_man">Intel manuals</a></p>
<p><a href="http://x86asm.net/links/index.html#sandpile">Sandpile.org</a></p>
<p><a href="http://x86asm.net/links/index.html#amd_man">AMD manuals</a></p>
<p>Intel iAPX 86/88, 186/188 User's manual</p>
<h2 id="Credits">Credits</h2>
<p>Thanks to all these geeks involved in some way in
  this project:</p>
<p>Christian Ludloff: maintainer of <a onclick="javascript:urchinTracker ('outgoing/http://sandpile.org');" href="http://sandpile.org/">Sandpile.org</a>
  site, one of important sources for this project</p>
<p><a onclick="javascript:urchinTracker ('outgoing/http://fasmlib.x86asm.net');" href="http://fasmlib.x86asm.net/">Martin Mocko</a>
  a.k.a. <strong>vid</strong>: many design ideas for <abbr>HTML</abbr>
  editions</p>
<p>Anthony Lopes: great <abbr>XML</abbr> and <abbr>XSL</abbr>
  contributions</p>
<p>Aquila: many great contributions</p>
<p><a onclick="javascript:urchinTracker ('outgoing/http://el1.cz/');" href="http://el1.cz/">EliCZ</a>: bug reports, design ideas</p>
<p>Cephexin: many great contributions to <abbr>XML</abbr></p>
<p>Miloslav Ponkrc: helped with PHP and JavaScript on this site</p>
<p>William Whistler: valuable reviews and bug reports</p>
<p>Mikae: reviews, bug reports</p>
<h2 id="References">References</h2>
<p><a onclick="javascript:urchinTracker ('outgoing/http://www.reddit.com/r/ReverseEngineering/comments/7j57x/handilyorganized_x86_instruction_and_opcode/');" href="http://www.reddit.com/r/ReverseEngineering/comments/7j57x/handilyorganized_x86_instruction_and_opcode/">Handily-organized
  x86 instruction and opcode references</a></p>
<p><a onclick="javascript:urchinTracker ('outgoing/http://qune.cside.com/archives/001054.html');" href="http://qune.cside.com/archives/001054.html">x86&#12458;&#12506;&#12467;&#12540;&#12489;&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;&#12381;&#12398;&#24460;&#12398;&#24460;</a></p>
<p><a onclick="javascript:urchinTracker ('outgoing/http://www.cyberhades.com/2009/12/18/referencia-de-instrucciones-y-codigos-de-operacion-opcodes-x86/');" href="http://www.cyberhades.com/2009/12/18/referencia-de-instrucciones-y-codigos-de-operacion-opcodes-x86/">
Referencia de Instrucciones y Cdigos de Operacin (OPCodes) x86</a></p>
<h2 id="Download">Download</h2>
<p>The source files can be downloaded from
  <a onclick="javascript:urchinTracker ('outgoing/https://github.com/Barebit/x86reference');" href="https://github.com/Barebit/x86reference">GitHub repository</a>.</p>
<h3>
<abbr>HTML</abbr> Editions Files</h3>
<table class="noborder" cellpadding="5">
    <tbody class="noborder">
      <tr class="noborder">
	<td class="noborder"><a href="http://ref.x86asm.net/coder.html">coder.html</a></td>
	<td class="noborder"><a href="http://ref.x86asm.net/coder-abc.html">coder-abc.html</a></td>
      </tr>
      <tr class="noborder">
	<td class="noborder"><a href="http://ref.x86asm.net/coder32.html">coder32.html</a></td>
	<td class="noborder"><a href="http://ref.x86asm.net/coder32-abc.html">coder32-abc.html</a></td>
      </tr>
      <tr class="noborder">
	<td class="noborder"><a href="http://ref.x86asm.net/coder64.html">coder64.html</a></td>
	<td class="noborder"><a href="http://ref.x86asm.net/coder64-abc.html">coder64-abc.html</a></td>
      </tr>
      <tr class="noborder">
	<td class="noborder"><a href="http://ref.x86asm.net/geek.html">geek.html</a></td>
	<td class="noborder"><a href="http://ref.x86asm.net/geek-abc.html">geek-abc.html</a></td>
      </tr>
      <tr class="noborder">
	<td class="noborder"><a href="http://ref.x86asm.net/geek32.html">geek32.html</a></td>
	<td class="noborder"><a href="http://ref.x86asm.net/geek32-abc.html">geek32-abc.html</a></td>
      </tr>
      <tr class="noborder">
	<td class="noborder"><a href="http://ref.x86asm.net/geek64.html">geek64.html</a></td>
	<td class="noborder"><a href="http://ref.x86asm.net/geek64-abc.html">geek64-abc.html</a></td>
      </tr>
    </tbody>
  </table>
<hr class="delimiter">
<h2 style="text-align: center;" id="Comments">Comments</h2>
<p style="text-align: center;">My
                      <a href="http://x86asm.net/contact/index.html">contact information is here</a>.
                        </p>
<hr class="delimiter">
<h2 style="text-align: center;" id="rev_history">Revisions</h2>
<table class="metainfo" cellpadding="3">
<tbody><tr>
<td>2017-02-18</td>
<td>1.12</td>
<td>
          Various bugfixes.
          See <a onclick="javascript:urchinTracker ('outgoing/https://github.com/Barebit/x86reference/releases');" href="https://github.com/Barebit/x86reference/releases">GitHub releases</a>
          for details.
        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2010-01-20</td>
<td>1.11</td>
<td>Mostly a bugfix release

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2009-08-19</td>
<td>1.10</td>
<td>
          <ul>
	    <li>All <abbr>SSE4</abbr> instructions (Aquila
	    contribution)</li>
	    <li>All <abbr>VMX</abbr> instructions</li>
	    <li>(the only) <abbr>SMX</abbr> instruction</li>
	    <li>All new general instructions: <code>POPCNT</code>,
	    <code>MOVBE</code>
</li>
	    <li>All new system instructions: <code>XGETBV</code>,
	    <code>XSETBV</code>, <code>RDTSCP</code>,
	    <code>XSAVE</code>, <code>XRSTOR</code>
</li>
	    <li>Processor code <code>C7</code> to indicate
	    Core&nbsp;i7</li>
	    <li>Implicate register operand group <code>xcr</code> (extended
	    control register) added because of <code>XGETBV</code> and
	    <code>XSETBV</code> instructions</li>
	  </ul>

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2009-06-30</td>
<td>1.02</td>
<td>The first version considered stable

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2008-12-17</td>
<td>1.01&#946;</td>
<td>Various bugfixes and updates

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2008-10-19</td>
<td>1.00&#946;</td>
<td>
          <ul>
	    <li>All <abbr>SSE</abbr>,
	    <abbr>SSE2</abbr>, <abbr>SSE3</abbr>, and
	    <abbr>SSSE3</abbr> instructions added (Aquila and
	    Cephexin contributions)</li>
            <li>
<a href="#Download">Alphabetically
	    sorted editions</a> (postfixed with
	    <dfn>-abc</dfn>)</li>
            
	  </ul>


        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2008-05-15</td>
<td>0.40&#946;</td>
<td>All <abbr>MMX</abbr> instructions added (Anthony Lopes contribution)

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2008-03-11</td>
<td>0.30&#946;</td>
<td>All x87 FPU instructions added, including new ones

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2007-11-29</td>
<td>0.21&#946;</td>
<td>Various changes

        </td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2007-11-06</td>
<td>0.20&#946;</td>
<td>Added coder, coder32, coder64, geek32, and
	geek64 editions. All main project's files modified. Project's
	documentation completed.</td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
<tbody><tr>
<td>2007-06-04</td>
<td>0.10&#946;</td>
<td>First public version</td>
<td>
                          MazeGen
                        </td>
</tr></tbody>
</table>
<p>
                (dates format correspond to 
              <a href="http://www.w3.org/QA/Tips/iso-date#good">ISO 8601</a>)
            </p>
</div>
<script src="X86%20Opcode%20and%20Instruction%20Reference-Dateien/urchin.js" type="text/javascript"></script><script type="text/javascript">
            _uacct = "UA-1649193-2";
          
        urchinTracker();
      </script>


</body></html>